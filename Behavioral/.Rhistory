}
mean(success)
200 * .7
# Power analysis
# (This is with no interaction - within-subjects one-way anova)
mean_yes = .5;
mean_no = .4;
sd = .35;
cor = .3;
cov = cor * (sd ^ 2);
#mean2a = .5;
#mean2b = .5;
n = 140
nTests = 1000
success = vector(mode = "logical", length = nTests)
for (i in 1:nTests) {
subjects <- mvrnorm(n, c(mean_yes, mean_no, mean_no),
matrix(c(sd ^ 2, cov, cov,
cov, sd ^ 2, cov,
cov, cov, sd ^ 2), nrow = 3))
my.df <- data.frame(subject = as.factor(rep(1:n, 3)),
condition = as.factor(rep(1:3, each = n)),
scr = as.vector(subjects))
fit <- ezANOVA(my.df, dv = scr, wid = subject, within = condition)
if (fit$ANOVA[1,5] < .05) {
success[i] = TRUE
}
}
c(.235, .268, -.041, .091, .138, .077, .173) ^ 2
rm(list=ls())
N <- 361 # sample size
J <- 7 # number of predictors
ss.reg <- 59.69 # sum of squares of regression model
ss.res <- 344.25 # sum of squares of residuals
ms.reg <- ss.reg / J # mean-square regression
ms.res <- ss.res / (N - J - 1) # mean-square residuals
## 3a.
# What % of the variation in opposition to affirmative action can be explained
# by the other variables?
# The % of variance explained by all of them is R-squared, which is
# SS-reg / (SS-reg + SS-res), or...
rsq <- ss.reg / (ss.reg + ss.res) # .15
# The % of variance that can be explained by each predictor (NOT controlling
# for other variables) is the square of the zero-order correlations, or...
c(.235, .268, -.041, .091, .138, .077, .173) ^ 2
# in the order on the homework:
# .055 .072 .0017 .0083 .019 .0059 .030
# The % of variance that can be explained by each predictor (controlling for the
# effects of the other predictors on this predictor) is the square of the semi-partial correlation
# between opposition to affirmative action and the predictor (available in the output), or..
c(.179, .178, -.029, .121, .0884, -.0347, .105) ^ 2
# in the order on the homework:
# .032 .032 .00084 .015 .0078 .0012 .011
f.stat <- ms.reg / ms.res
# and get the p value by using the F distribution function...
pf(f.stat, J, N - J - 1, lower.tail = F)
rsq.adj <- 1 - (1 - rsq) * (N - 1) / (N - J - 1) # .13
var.res <- ss.res / (N - J - 1) # .98
.0884 ^ 2 # .0078
b.educ <- .143 * 1.059 / 1.618
# then, calculate a t statistic by t(N - J - 1) = b / std-error(b), pulling std-error(b) from the
# output, or...
t.stat.educ <- b.educ / .038
# finally, get the (2-tailed) p value by looking up this value in the t distribution
2 * pt(t.stat.educ, N - J - 1, lower.tail = FALSE) # .014
# p < .05; opposition to affirmative action can be predicted by education at an above-chance level
## 3g.
# Same explanation as above.
b.sdo <- .115 * 1.059 / .114
# As it's not in the output, this time we need to calculate the standard error of the unstandarized
# coefficient by:
# std-error-b <- sqrt(std-error-estimate ^ 2 / (ss-SDO * (1 - coef-of-multicollinearity)))
se.estimate.sdo <- sqrt(ss.res / N) # .98
se.estimate.sdo <- sqrt(ss.res / N) # .98
# to get the ss-SDO, we square the standard deviation of SDO (to get variance)
# and then multiply by N. (We're assuming that SPSS isn't reporting the
# unbiased estimate of population standard deviation.)
ss.sdo <- (.114 ^ 2) * N
# note that (1 - coef-of-multicollinearity(sdo)) = tolerance(sdo),
# which is given
tol.sdo <- .843
# so:
se.b.sdo <- sqrt((se.estimate.sdo ^ 2) / (ss.sdo * tol.sdo)) # .49
t.stat.sdo <- b.sdo / se.b.sdo # 2.18
2 * pt(t.stat.sdo, N - J - 1, lower.tail = FALSE) # .030
# p < .05; opposition to affirmative action can be predicted by SDO at an above-chance level
## 3h.
cor.aa.ed <- .091
cor.aa.sdo <- .173
cor.ed.sdo <- -.228
# This semi-partial correlation is a measure of the relationship between affirmative action
# opposition and education, controlling for the effect of SDO on education. It is calculated by:
spcor.aa.ed <- (cor.aa.ed - cor.aa.sdo * cor.ed.sdo) / sqrt(1 - cor.ed.sdo ^ 2) # .13
# Power analysis
# (This is with no interaction - within-subjects one-way anova)
mean_yes = .5;
mean_no = .4;
sd = .35;
cor = .3;
cov = cor * (sd ^ 2);
#mean2a = .5;
#mean2b = .5;
n = 140
nTests = 1000
success = vector(mode = "logical", length = nTests)
for (i in 1:nTests) {
subjects <- mvrnorm(n, c(mean_yes, mean_no, mean_no),
matrix(c(sd ^ 2, cov, cov,
cov, sd ^ 2, cov,
cov, cov, sd ^ 2), nrow = 3))
my.df <- data.frame(subject = as.factor(rep(1:n, 3)),
condition = as.factor(rep(1:3, each = n)),
scr = as.vector(subjects))
fit <- ezANOVA(my.df, dv = scr, wid = subject, within = condition)
if (fit$ANOVA[1,5] < .05) {
success[i] = TRUE
}
}
mean(success)
install.packages("BiasedUrn")
setwd("~/Me/Psychology/Projects/StealPunish/git/Behavioral/v3/real2")
require(lme4)
require(lmerTest)
require(dplyr)
require(ggplot2)
theme_mprl <- function () {
theme_minimal() +
theme(plot.title = element_text(vjust=3.5, size=18),
axis.title.x = element_text(vjust=-2.5, size=16, face="bold"),
axis.title.y = element_text(vjust=3.5, size=16, face="bold"),
axis.text = element_text(size = rel(1)),
axis.line = element_line(),
legend.text = element_text(size = 14),
plot.margin = unit(c(3,3,3,3), "lines"),
panel.grid.major = element_blank(), panel.grid.minor = element_blank())
}
theme_adam = function() {
theme_classic() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.text=element_text(size=22, colour = "black"), axis.title=element_text(size=24, face = "bold"), axis.title.x = element_text(vjust = 0),
legend.title = element_text(size = 24, face = "bold"), legend.text = element_text(size = 20), plot.title = element_text(size = 26, face = "bold", vjust = 1),
plot.margin = unit(c(3,3,3,3), "lines"))
}
se = function(x) {return(sd(x)/sqrt(length(x)))}
dodge <- position_dodge(width=0)
lm.beta.lmer <- function(mod) {
b <- fixef(mod)[-1]
sd.x <- apply(getME(mod,"X")[,-1],2,sd)
sd.y <- sd(getME(mod,"y"))
b*sd.x/sd.y
}
df <- read.csv('data.csv') %>%
mutate(role = factor(role, c(1, 0), c('Victim', 'Thief')))
df.persist <- df %>% filter(oppType == 2)
df.collapsed = df.persist %>%
mutate(choice = choice * 100) %>%
group_by(role, matchRound) %>%
summarize(choice.m = mean(choice), choice.se = se(choice))
df.collapsed
ggplot(data = df.collapsed, aes(x = matchRound, y = choice.m, color = role, group = role, linetype = role)) +
geom_line() +
geom_errorbar(aes(ymax = choice.m + choice.se, ymin = choice.m - choice.se), width = .5, position = dodge) +
theme_adam() + xlab('Round') + ylab('% Stealing / punishing') +
scale_x_continuous(limits = c(-1,20), breaks = c(0,9,19), labels = c(1, 10, 20)) + scale_y_continuous(limits = c(0,100), breaks = c(0,50,100)) +
theme(legend.title=element_blank(), legend.position = c(1,1), legend.justification = c(.9,.9)) +
scale_colour_manual(values = c("Thief" = "Red", "Victim" = "Blue")) +
ggsave(file='test.eps')
setwd("~/Me/Psychology/Projects/StealPunish/git/Behavioral/random_payoffs")
require(lme4)
require(lmerTest)
require(dplyr)
require(ggplot2)
theme_mprl <- function () {
theme_minimal() +
theme(plot.title = element_text(vjust=3.5, size=18),
axis.title.x = element_text(vjust=-2.5, size=16, face="bold"),
axis.title.y = element_text(vjust=3.5, size=16, face="bold"),
axis.text = element_text(size = rel(1)),
axis.line = element_line(),
legend.text = element_text(size = 14),
plot.margin = unit(c(3,3,3,3), "lines"),
panel.grid.major = element_blank(), panel.grid.minor = element_blank())
}
theme_adam = function() {
theme_classic() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.text=element_text(size=22, colour = "black"), axis.title=element_text(size=24, face = "bold"), axis.title.x = element_text(vjust = 0),
legend.title = element_text(size = 24, face = "bold"), legend.text = element_text(size = 20), plot.title = element_text(size = 26, face = "bold", vjust = 1),
plot.margin = unit(c(3,3,3,3), "lines"))
}
se = function(x) {return(sd(x)/sqrt(length(x)))}
dodge <- position_dodge(width=0)
lm.beta.lmer <- function(mod) {
b <- fixef(mod)[-1]
sd.x <- apply(getME(mod,"X")[,-1],2,sd)
sd.y <- sd(getME(mod,"y"))
b*sd.x/sd.y
}
# Load data, focus on persistent opponents
df <- read.csv('data.csv') %>%
mutate(role = factor(role, c(1, 0), c('Victim', 'Thief')))
df.persist <- df %>% filter(oppType == 2)
pointsPerCent = 1
df.demo = read.csv('demo.csv')
df.demo = df.demo %>% mutate(total_time_actual = total_time / 60000, bonus = round(bonus / (pointsPerCent * 100), 2))
write.table(df.demo %>% select(WorkerID = subject, Bonus = bonus),
'Bonuses - sp_rp.csv', row.names = FALSE, col.names = FALSE, sep = ",")
rm(list=ls())
theme_adam = function() {
theme_classic() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.text=element_text(size=22, colour = "black"), axis.title=element_text(size=24, face = "bold"), axis.title.x = element_text(vjust = 0),
legend.title = element_text(size = 24, face = "bold"), legend.text = element_text(size = 20), plot.title = element_text(size = 26, face = "bold", vjust = 1),
plot.margin = unit(c(3,3,3,3), "lines"))
}
se = function(x) {return(sd(x)/sqrt(length(x)))}
dodge <- position_dodge(width=0)
## ANALYSIS
# Load data, focus on persistent opponents
df <- read.csv('data.csv') %>%
mutate(role = factor(role, c(1, 0), c('Victim', 'Thief')))
df.persist <- df %>% filter(oppType == 2)
# Run mixed-effect model (with order), compare to null
model = glmer(choice ~ role * matchRound * orderCond + (1 + matchRound | subject),
family = binomial, data = df.persist);
model.null = glmer(choice ~ role + matchRound * orderCond + role:matchRound:orderCond + role:orderCond + (1 + matchRound | subject),
family = binomial, data = df.persist);
anova(model, model.null)
# Run mixed-effect model (without order), compare to null
model2 = glmer(choice ~ role * matchRound + (1 + matchRound | subject),
family = binomial, data = df.persist);
model2.null = glmer(choice ~ role + matchRound + (1 + matchRound | subject),
family = binomial, data = df.persist);
anova(model2, model2.null)
# Plot
df.collapsed = df.persist %>%
mutate(choice = choice * 100) %>%
group_by(role, matchRound) %>%
summarize(choice.m = mean(choice), choice.se = se(choice))
df.collapsed
ggplot(data = df.collapsed, aes(x = matchRound, y = choice.m, color = role, group = role, linetype = role)) +
geom_line() +
geom_errorbar(aes(ymax = choice.m + choice.se, ymin = choice.m - choice.se), width = .5, position = dodge) +
theme_adam() + xlab('Round') + ylab('% Stealing / punishing') +
scale_x_continuous(limits = c(-1,20), breaks = c(0,9,19), labels = c(1, 10, 20)) + scale_y_continuous(limits = c(0,100), breaks = c(0,50,100)) +
theme(legend.title=element_blank(), legend.position = c(1,1), legend.justification = c(.9,.9)) +
scale_colour_manual(values = c("Thief" = "Red", "Victim" = "Blue"))
## FOR RANDOM_PAYOFFS VERSION
# Check whether people are sensitive to varying payoffs
# For victim, only analyzing against persistent opponents (because this is the main opportunity to punish)
model.thief.s = glmer(choice ~ s + (1 | subject),
family = binomial, data = df %>% filter(role == 'Thief'));
model.thief.c = glmer(choice ~ c + (1 | subject),
family = binomial, data = df %>% filter(role == 'Thief'));
model.thief.p = glmer(choice ~ p + (1 | subject),
family = binomial, data = df %>% filter(role == 'Thief'));
model.thief.null = glmer(choice ~ 1 + (1 | subject),
family = binomial, data = df %>% filter(role == 'Thief'));
anova(model.thief.s, model.thief.null)
anova(model.thief.c, model.thief.null)
anova(model.thief.p, model.thief.null)
# had to switch optimizers for convergence
model.victim.c = glmer(choice ~ c + (1 | subject),
family = binomial, data = df %>% filter(role == 'Victim' & oppType == 2),
control = glmerControl(optimizer='bobyqa'));
model.victim.s = glmer(choice ~ s + (1 | subject),
family = binomial, data = df %>% filter(role == 'Victim' & oppType == 2),
control = glmerControl(optimizer='bobyqa'));
model.victim.p = glmer(choice ~ p + (1 | subject),
family = binomial, data = df %>% filter(role == 'Victim' & oppType == 2),
control = glmerControl(optimizer='bobyqa'));
model.victim.null = glmer(choice ~ 1 + (1 | subject),
family = binomial, data = df %>% filter(role == 'Victim' & oppType == 2),
control = glmerControl(optimizer='bobyqa'));
anova(model.victim.c, model.victim.null)
anova(model.victim.s, model.victim.null)
anova(model.victim.p, model.victim.null)
## PRELIMINARIES
# You should set the working directory to the current folder
require(lme4)
require(lmerTest)
require(dplyr)
require(ggplot2)
theme_adam = function() {
theme_classic() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.text=element_text(size=22, colour = "black"), axis.title=element_text(size=24, face = "bold"), axis.title.x = element_text(vjust = 0),
legend.title = element_text(size = 24, face = "bold"), legend.text = element_text(size = 20), plot.title = element_text(size = 26, face = "bold", vjust = 1),
plot.margin = unit(c(3,3,3,3), "lines"))
}
se = function(x) {return(sd(x)/sqrt(length(x)))}
dodge <- position_dodge(width=0)
## ANALYSIS
fixed_payoffs = T
# Load data, focus on persistent opponents
df <- read.csv(ifelse(fixed_payoffs, 'fixed_payoffs.csv', 'random_payoffs.csv')) %>%
mutate(role = factor(role, c(1, 0), c('Victim', 'Thief')))
df.persist <- df %>% filter(oppType == 2)
# Run mixed-effect model (with order), compare to null
model = glmer(choice ~ role * matchRound * orderCond + (1 + matchRound | subject),
family = binomial, data = df.persist);
model.null = glmer(choice ~ role + matchRound * orderCond + role:matchRound:orderCond + role:orderCond + (1 + matchRound | subject),
family = binomial, data = df.persist);
anova(model, model.null)
# Run mixed-effect model (without order), compare to null
model2 = glmer(choice ~ role * matchRound + (1 + matchRound | subject),
family = binomial, data = df.persist);
model2.null = glmer(choice ~ role + matchRound + (1 + matchRound | subject),
family = binomial, data = df.persist);
anova(model2, model2.null)
# Plot
df.collapsed = df.persist %>%
mutate(choice = choice * 100) %>%
group_by(role, matchRound) %>%
summarize(choice.m = mean(choice), choice.se = se(choice))
df.collapsed
ggplot(data = df.collapsed, aes(x = matchRound, y = choice.m, color = role, group = role, linetype = role)) +
geom_line() +
geom_errorbar(aes(ymax = choice.m + choice.se, ymin = choice.m - choice.se), width = .5, position = dodge) +
theme_adam() + xlab('Round') + ylab('% Stealing / punishing') +
scale_x_continuous(limits = c(-1,20), breaks = c(0,9,19), labels = c(1, 10, 20)) + scale_y_continuous(limits = c(0,100), breaks = c(0,50,100)) +
theme(legend.title=element_blank(), legend.position = c(1,1), legend.justification = c(.9,.9)) +
scale_colour_manual(values = c("Thief" = "Red", "Victim" = "Blue"))
## FOR RANDOM_PAYOFFS VERSION
if (!fixed_payoffs) {
# Check whether people are sensitive to varying payoffs
# For victim, only analyzing against persistent opponents (because this is the main opportunity to punish)
model.thief.s = glmer(choice ~ s + (1 | subject),
family = binomial, data = df %>% filter(role == 'Thief'));
model.thief.c = glmer(choice ~ c + (1 | subject),
family = binomial, data = df %>% filter(role == 'Thief'));
model.thief.p = glmer(choice ~ p + (1 | subject),
family = binomial, data = df %>% filter(role == 'Thief'));
model.thief.null = glmer(choice ~ 1 + (1 | subject),
family = binomial, data = df %>% filter(role == 'Thief'));
anova(model.thief.s, model.thief.null)
anova(model.thief.c, model.thief.null)
anova(model.thief.p, model.thief.null)
# had to switch optimizers for convergence
model.victim.c = glmer(choice ~ c + (1 | subject),
family = binomial, data = df %>% filter(role == 'Victim' & oppType == 2),
control = glmerControl(optimizer='bobyqa'));
model.victim.s = glmer(choice ~ s + (1 | subject),
family = binomial, data = df %>% filter(role == 'Victim' & oppType == 2),
control = glmerControl(optimizer='bobyqa'));
model.victim.p = glmer(choice ~ p + (1 | subject),
family = binomial, data = df %>% filter(role == 'Victim' & oppType == 2),
control = glmerControl(optimizer='bobyqa'));
model.victim.null = glmer(choice ~ 1 + (1 | subject),
family = binomial, data = df %>% filter(role == 'Victim' & oppType == 2),
control = glmerControl(optimizer='bobyqa'));
anova(model.victim.c, model.victim.null)
anova(model.victim.s, model.victim.null)
anova(model.victim.p, model.victim.null)
}
setwd("~/Me/Psychology/Projects/StealPunish/git/Behavioral")
## PRELIMINARIES
# You should set the working directory to the current folder
require(lme4)
require(lmerTest)
require(dplyr)
require(ggplot2)
theme_adam = function() {
theme_classic() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.text=element_text(size=22, colour = "black"), axis.title=element_text(size=24, face = "bold"), axis.title.x = element_text(vjust = 0),
legend.title = element_text(size = 24, face = "bold"), legend.text = element_text(size = 20), plot.title = element_text(size = 26, face = "bold", vjust = 1),
plot.margin = unit(c(3,3,3,3), "lines"))
}
se = function(x) {return(sd(x)/sqrt(length(x)))}
dodge <- position_dodge(width=0)
## ANALYSIS
fixed_payoffs = T
# Load data, focus on persistent opponents
df <- read.csv(ifelse(fixed_payoffs, 'fixed_payoffs.csv', 'random_payoffs.csv')) %>%
mutate(role = factor(role, c(1, 0), c('Victim', 'Thief')))
df.persist <- df %>% filter(oppType == 2)
# Run mixed-effect model (with order), compare to null
model = glmer(choice ~ role * matchRound * orderCond + (1 + matchRound | subject),
family = binomial, data = df.persist);
model.null = glmer(choice ~ role + matchRound * orderCond + role:matchRound:orderCond + role:orderCond + (1 + matchRound | subject),
family = binomial, data = df.persist);
anova(model, model.null)
# Run mixed-effect model (without order), compare to null
model2 = glmer(choice ~ role * matchRound + (1 + matchRound | subject),
family = binomial, data = df.persist);
model2.null = glmer(choice ~ role + matchRound + (1 + matchRound | subject),
family = binomial, data = df.persist);
anova(model2, model2.null)
# Plot
df.collapsed = df.persist %>%
mutate(choice = choice * 100) %>%
group_by(role, matchRound) %>%
summarize(choice.m = mean(choice), choice.se = se(choice))
df.collapsed
ggplot(data = df.collapsed, aes(x = matchRound, y = choice.m, color = role, group = role, linetype = role)) +
geom_line() +
geom_errorbar(aes(ymax = choice.m + choice.se, ymin = choice.m - choice.se), width = .5, position = dodge) +
theme_adam() + xlab('Round') + ylab('% Stealing / punishing') +
scale_x_continuous(limits = c(-1,20), breaks = c(0,9,19), labels = c(1, 10, 20)) + scale_y_continuous(limits = c(0,100), breaks = c(0,50,100)) +
theme(legend.title=element_blank(), legend.position = c(1,1), legend.justification = c(.9,.9)) +
scale_colour_manual(values = c("Thief" = "Red", "Victim" = "Blue"))
## FOR RANDOM_PAYOFFS VERSION
if (!fixed_payoffs) {
# Check whether people are sensitive to varying payoffs
# For victim, only analyzing against persistent opponents (because this is the main opportunity to punish)
model.thief.s = glmer(choice ~ s + (1 | subject),
family = binomial, data = df %>% filter(role == 'Thief'));
model.thief.c = glmer(choice ~ c + (1 | subject),
family = binomial, data = df %>% filter(role == 'Thief'));
model.thief.p = glmer(choice ~ p + (1 | subject),
family = binomial, data = df %>% filter(role == 'Thief'));
model.thief.null = glmer(choice ~ 1 + (1 | subject),
family = binomial, data = df %>% filter(role == 'Thief'));
anova(model.thief.s, model.thief.null)
anova(model.thief.c, model.thief.null)
anova(model.thief.p, model.thief.null)
# had to switch optimizers for convergence
model.victim.c = glmer(choice ~ c + (1 | subject),
family = binomial, data = df %>% filter(role == 'Victim' & oppType == 2),
control = glmerControl(optimizer='bobyqa'));
model.victim.s = glmer(choice ~ s + (1 | subject),
family = binomial, data = df %>% filter(role == 'Victim' & oppType == 2),
control = glmerControl(optimizer='bobyqa'));
model.victim.p = glmer(choice ~ p + (1 | subject),
family = binomial, data = df %>% filter(role == 'Victim' & oppType == 2),
control = glmerControl(optimizer='bobyqa'));
model.victim.null = glmer(choice ~ 1 + (1 | subject),
family = binomial, data = df %>% filter(role == 'Victim' & oppType == 2),
control = glmerControl(optimizer='bobyqa'));
anova(model.victim.c, model.victim.null)
anova(model.victim.s, model.victim.null)
anova(model.victim.p, model.victim.null)
}
## PRELIMINARIES
# You should set the working directory to the current folder
require(lme4)
require(lmerTest)
require(dplyr)
require(ggplot2)
theme_adam = function() {
theme_classic() + theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
axis.text=element_text(size=22, colour = "black"), axis.title=element_text(size=24, face = "bold"), axis.title.x = element_text(vjust = 0),
legend.title = element_text(size = 24, face = "bold"), legend.text = element_text(size = 20), plot.title = element_text(size = 26, face = "bold", vjust = 1),
plot.margin = unit(c(3,3,3,3), "lines"))
}
se = function(x) {return(sd(x)/sqrt(length(x)))}
dodge <- position_dodge(width=0)
## ANALYSIS
fixed_payoffs = F
# Load data, focus on persistent opponents
df <- read.csv(ifelse(fixed_payoffs, 'fixed_payoffs.csv', 'random_payoffs.csv')) %>%
mutate(role = factor(role, c(1, 0), c('Victim', 'Thief')))
df.persist <- df %>% filter(oppType == 2)
# Run mixed-effect model (with order), compare to null
model = glmer(choice ~ role * matchRound * orderCond + (1 + matchRound | subject),
family = binomial, data = df.persist);
model.null = glmer(choice ~ role + matchRound * orderCond + role:matchRound:orderCond + role:orderCond + (1 + matchRound | subject),
family = binomial, data = df.persist);
anova(model, model.null)
# Run mixed-effect model (without order), compare to null
model2 = glmer(choice ~ role * matchRound + (1 + matchRound | subject),
family = binomial, data = df.persist);
model2.null = glmer(choice ~ role + matchRound + (1 + matchRound | subject),
family = binomial, data = df.persist);
anova(model2, model2.null)
# Plot
df.collapsed = df.persist %>%
mutate(choice = choice * 100) %>%
group_by(role, matchRound) %>%
summarize(choice.m = mean(choice), choice.se = se(choice))
df.collapsed
ggplot(data = df.collapsed, aes(x = matchRound, y = choice.m, color = role, group = role, linetype = role)) +
geom_line() +
geom_errorbar(aes(ymax = choice.m + choice.se, ymin = choice.m - choice.se), width = .5, position = dodge) +
theme_adam() + xlab('Round') + ylab('% Stealing / punishing') +
scale_x_continuous(limits = c(-1,20), breaks = c(0,9,19), labels = c(1, 10, 20)) + scale_y_continuous(limits = c(0,100), breaks = c(0,50,100)) +
theme(legend.title=element_blank(), legend.position = c(1,1), legend.justification = c(.9,.9)) +
scale_colour_manual(values = c("Thief" = "Red", "Victim" = "Blue"))
## FOR RANDOM_PAYOFFS VERSION
if (!fixed_payoffs) {
# Check whether people are sensitive to varying payoffs
# For victim, only analyzing against persistent opponents (because this is the main opportunity to punish)
model.thief.s = glmer(choice ~ s + (1 | subject),
family = binomial, data = df %>% filter(role == 'Thief'));
model.thief.c = glmer(choice ~ c + (1 | subject),
family = binomial, data = df %>% filter(role == 'Thief'));
model.thief.p = glmer(choice ~ p + (1 | subject),
family = binomial, data = df %>% filter(role == 'Thief'));
model.thief.null = glmer(choice ~ 1 + (1 | subject),
family = binomial, data = df %>% filter(role == 'Thief'));
anova(model.thief.s, model.thief.null)
anova(model.thief.c, model.thief.null)
anova(model.thief.p, model.thief.null)
# had to switch optimizers for convergence
model.victim.c = glmer(choice ~ c + (1 | subject),
family = binomial, data = df %>% filter(role == 'Victim' & oppType == 2),
control = glmerControl(optimizer='bobyqa'));
model.victim.s = glmer(choice ~ s + (1 | subject),
family = binomial, data = df %>% filter(role == 'Victim' & oppType == 2),
control = glmerControl(optimizer='bobyqa'));
model.victim.p = glmer(choice ~ p + (1 | subject),
family = binomial, data = df %>% filter(role == 'Victim' & oppType == 2),
control = glmerControl(optimizer='bobyqa'));
model.victim.null = glmer(choice ~ 1 + (1 | subject),
family = binomial, data = df %>% filter(role == 'Victim' & oppType == 2),
control = glmerControl(optimizer='bobyqa'));
anova(model.victim.c, model.victim.null)
anova(model.victim.s, model.victim.null)
anova(model.victim.p, model.victim.null)
}
anova(model.thief.s, model.thief.null)
anova(model.thief.c, model.thief.null)
anova(model.thief.p, model.thief.null)
anova(model.victim.c, model.victim.null)
anova(model.victim.s, model.victim.null)
anova(model.victim.p, model.victim.null)
